#!/bin/bash

# CONSTRUCT Quality Check Script
# Validates shell script quality and CONSTRUCT development standards

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Source library functions
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../lib/common-patterns.sh"
source "$SCRIPT_DIR/../lib/validation.sh"

# Get project directories using library functions
CONSTRUCT_ROOT=$(get_construct_root)
CONSTRUCT_DEV=$(get_construct_dev)

# Setup report file
REPORT_DIR="$CONSTRUCT_DEV/AI/dev-logs/check-quality/automated"
mkdir -p "$REPORT_DIR"
REPORT_FILE="$REPORT_DIR/quality-report-$(date +%Y-%m-%d--%H-%M-%S).md"

# Function to output to both terminal and report file
log_output() {
    echo -e "$1"
    echo -e "$1" | sed 's/\x1b\[[0-9;]*m//g' >> "$REPORT_FILE"
}

# Initialize report file
cat > "$REPORT_FILE" << EOF
# CONSTRUCT Quality Check Report

**Date**: $(date)
**Generated by**: check-quality.sh
**Script version**: v1.0

## Summary

Quality check results for CONSTRUCT development environment.

---

EOF

log_output "${BLUE}üîç Running CONSTRUCT Quality Checks...${NC}"
log_output ""

VIOLATIONS=0

# Check 1: Shell script syntax validation
log_output "${BLUE}### 1. Validating shell script syntax...${NC}"
check_shell_syntax() {
    local syntax_errors=0
    
    find_shell_scripts "$CONSTRUCT_DEV" | while read -r script; do
        if ! bash -n "$script" 2>/dev/null; then
            log_output "${RED}‚ùå Syntax error in: $(basename "$script")${NC}"
            bash -n "$script" 2>&1 | head -3 | sed 's/^/   /' | while read -r line; do
                log_output "   $line"
            done
            ((syntax_errors++))
        fi
    done
    
    if [ $syntax_errors -eq 0 ]; then
        log_output "${GREEN}‚úÖ All shell scripts have valid syntax${NC}"
    else
        log_output "${YELLOW}   Fix: Check shell script syntax errors above${NC}"
        VIOLATIONS=$((VIOLATIONS + syntax_errors))
    fi
}
check_shell_syntax
log_output ""

# Check 2: Error handling patterns
log_output "${BLUE}### 2. Checking error handling patterns...${NC}"
check_error_handling() {
    local missing_error_handling=0
    
    find_shell_scripts "$CONSTRUCT_DEV/CONSTRUCT/scripts" | while read -r script; do
        local has_set_e=$(safe_grep_count "^set -e" "$script")
        local has_error_trap=$(safe_grep_count "trap.*ERR\|trap.*EXIT" "$script")
        
        if [ "$has_set_e" -eq 0 ] && [ "$has_error_trap" -eq 0 ]; then
            log_output "${YELLOW}‚ö†Ô∏è Missing error handling: $(basename "$script")${NC}"
            ((missing_error_handling++))
        fi
    done
    
    if [ $missing_error_handling -eq 0 ]; then
        log_output "${GREEN}‚úÖ All scripts have proper error handling${NC}"
    else
        log_output "${YELLOW}   Fix: Add 'set -e' or error traps to scripts${NC}"
    fi
}
check_error_handling
log_output ""

# Check 3: Hardcoded paths
log_output "${BLUE}### 3. Checking for hardcoded paths...${NC}"
check_hardcoded_paths() {
    local hardcoded_paths=0
    
    # Look for suspicious hardcoded paths (excluding this pattern definition)
    local suspicious_patterns="/Users/\|/home/\|^[[:space:]]*/tmp/[a-zA-Z]\|/var/folders"
    
    find_shell_scripts "$CONSTRUCT_DEV" | while read -r script; do
        local violations=$(grep -n "$suspicious_patterns" "$script" 2>/dev/null | grep -v "# Example\|# TODO\|suspicious_patterns=\|Look for suspicious" || echo "")
        
        if [ -n "$violations" ]; then
            log_output "${RED}‚ùå Hardcoded paths in: $(basename "$script")${NC}"
            echo "$violations" | head -3 | sed 's/^/   /' | while read -r line; do
                log_output "   $line"
            done
            ((hardcoded_paths++))
        fi
    done
    
    if [ $hardcoded_paths -eq 0 ]; then
        log_output "${GREEN}‚úÖ No hardcoded paths found${NC}"
    else
        log_output "${YELLOW}   Fix: Use relative paths and environment variables${NC}"
        VIOLATIONS=$((VIOLATIONS + hardcoded_paths))
    fi
}
check_hardcoded_paths
log_output ""

# Check 4: Function documentation
log_output "${BLUE}### 4. Checking function documentation...${NC}"
check_function_docs() {
    local undocumented_functions=0
    
    find_shell_scripts "$CONSTRUCT_DEV/CONSTRUCT/lib" | while read -r lib_file; do
        log_output "${YELLOW}Checking: $(basename "$lib_file")${NC}"
        
        # Find function definitions
        local functions=$(grep -n "^[a-zA-Z_][a-zA-Z0-9_]*()" "$lib_file" | cut -d':' -f1)
        
        for line_num in $functions; do
            local func_name=$(sed -n "${line_num}p" "$lib_file" | cut -d'(' -f1)
            
            # Check if function has documentation comment before it
            local prev_line=$((line_num - 1))
            if [ $prev_line -gt 0 ]; then
                local comment=$(sed -n "${prev_line}p" "$lib_file")
                if [[ ! "$comment" =~ ^#.*[A-Za-z] ]]; then
                    log_output "${YELLOW}‚ö†Ô∏è Function lacks documentation: $func_name${NC}"
                    ((undocumented_functions++))
                fi
            fi
        done
    done
    
    if [ $undocumented_functions -eq 0 ]; then
        log_output "${GREEN}‚úÖ All library functions are documented${NC}"
    else
        log_output "${YELLOW}   Fix: Add comment before each function explaining purpose${NC}"
    fi
}
check_function_docs
log_output ""

# Check 5: Script executable permissions
log_output "${BLUE}### 5. Checking script permissions...${NC}"
check_script_permissions() {
    local non_executable=0
    
    find_shell_scripts "$CONSTRUCT_DEV/CONSTRUCT/scripts" | while read -r script; do
        if [ ! -x "$script" ]; then
            log_output "${RED}‚ùå Not executable: $(basename "$script")${NC}"
            ((non_executable++))
        fi
    done
    
    if [ $non_executable -eq 0 ]; then
        log_output "${GREEN}‚úÖ All AI scripts are executable${NC}"
    else
        log_output "${YELLOW}   Fix: chmod +x for non-executable scripts${NC}"
        VIOLATIONS=$((VIOLATIONS + non_executable))
    fi
}
check_script_permissions
log_output ""

# Check 6: Configuration file validation
log_output "${BLUE}### 6. Validating configuration files...${NC}"
check_config_files() {
    local config_errors=0
    
    find "$CONSTRUCT_DEV/CONSTRUCT/config" -name "*.yaml" -type f | while read -r config_file; do
        log_output "${YELLOW}Checking: $(basename "$config_file")${NC}"
        
        # Basic YAML syntax check
        if command -v python3 &> /dev/null; then
            if python3 -c "import sys; sys.exit(0 if 'yaml' in sys.modules or __import__('yaml') else 1)" 2>/dev/null; then
                if ! python3 -c "import yaml; yaml.safe_load(open('$config_file'))" 2>/dev/null; then
                    log_output "${RED}‚ùå Invalid YAML syntax: $(basename "$config_file")${NC}"
                    ((config_errors++))
                fi
            else
                log_output "${YELLOW}‚ö†Ô∏è PyYAML not installed, skipping syntax check for: $(basename "$config_file")${NC}"
            fi
        else
            # Fallback basic checks
            if grep -q "^[[:space:]]*-[[:space:]]*$" "$config_file"; then
                log_output "${YELLOW}‚ö†Ô∏è Empty list items in: $(basename "$config_file")${NC}"
            fi
            
            # Check for basic YAML structure
            if ! grep -q "^[a-zA-Z_][a-zA-Z0-9_]*:" "$config_file"; then
                log_output "${YELLOW}‚ö†Ô∏è No valid YAML keys found in: $(basename "$config_file")${NC}"
                ((config_errors++))
            fi
        fi
        
        # Check for required sections
        case "$(basename "$config_file")" in
            "mvvm-rules.yaml")
                if ! grep -q "rules:" "$config_file"; then
                    log_output "${YELLOW}‚ö†Ô∏è Missing 'rules' section in mvvm-rules.yaml${NC}"
                fi
                ;;
            "quality-gates.yaml")
                if ! grep -q "thresholds:\|gates:" "$config_file"; then
                    log_output "${YELLOW}‚ö†Ô∏è Missing quality sections in quality-gates.yaml${NC}"
                fi
                ;;
        esac
    done
    
    if [ $config_errors -eq 0 ]; then
        log_output "${GREEN}‚úÖ Configuration files are valid${NC}"
    else
        log_output "${YELLOW}   Fix: Resolve YAML syntax errors${NC}"
        VIOLATIONS=$((VIOLATIONS + config_errors))
    fi
}
check_config_files
log_output ""

# Check 7: Library function usage
log_output "${BLUE}### 7. Checking library function usage...${NC}"
check_library_usage() {
    local missing_imports=0
    
    find_shell_scripts "$CONSTRUCT_DEV/CONSTRUCT/scripts" | while read -r script; do
        # Check if script sources library functions it uses
        local uses_validation=$(safe_grep_count "validate_\|check_" "$script" 2>/dev/null | tr -d ' \n' || echo "0")
        local sources_validation=$(safe_grep_count "source.*validation.sh" "$script" 2>/dev/null | tr -d ' \n' || echo "0")
        
        if [ "$uses_validation" -gt 0 ] && [ "$sources_validation" -eq 0 ]; then
            log_output "${YELLOW}‚ö†Ô∏è Uses validation functions but doesn't source validation.sh: $(basename "$script")${NC}"
            ((missing_imports++))
        fi
        
        local uses_file_analysis=$(safe_grep_count "analyze_\|parse_" "$script" 2>/dev/null | tr -d ' \n' || echo "0")
        local sources_file_analysis=$(safe_grep_count "source.*file-analysis.sh" "$script" 2>/dev/null | tr -d ' \n' || echo "0")
        
        if [ "$uses_file_analysis" -gt 0 ] && [ "$sources_file_analysis" -eq 0 ]; then
            log_output "${YELLOW}‚ö†Ô∏è Uses file analysis but doesn't source file-analysis.sh: $(basename "$script")${NC}"
            ((missing_imports++))
        fi
    done
    
    if [ $missing_imports -eq 0 ]; then
        log_output "${GREEN}‚úÖ Library functions are properly sourced${NC}"
    else
        log_output "${YELLOW}   Fix: Add proper source statements for library functions${NC}"
    fi
}
check_library_usage
log_output ""

# Check 8: Output formatting consistency
log_output "${BLUE}### 8. Checking output formatting...${NC}"
check_output_formatting() {
    local inconsistent_output=0
    
    find_shell_scripts "$CONSTRUCT_DEV/CONSTRUCT/scripts" | while read -r script; do
        # Check for colored output consistency
        local has_colors=$(safe_grep_count "RED=\|GREEN=\|YELLOW=\|BLUE=" "$script")
        local uses_echo_e=$(safe_grep_count "echo -e" "$script")
        
        if [ "$uses_echo_e" -gt 0 ] && [ "$has_colors" -eq 0 ]; then
            log_output "${YELLOW}‚ö†Ô∏è Uses echo -e but no color definitions: $(basename "$script")${NC}"
            ((inconsistent_output++))
        fi
        
        # Check for consistent status indicators
        local has_status_indicators=$(safe_grep_count "‚úÖ\|‚ùå\|‚ö†Ô∏è" "$script")
        if [ "$has_status_indicators" -eq 0 ] && [ "$(basename "$script")" != "before_coding.sh" ]; then
            log_output "${YELLOW}‚ö†Ô∏è No status indicators found: $(basename "$script")${NC}"
            ((inconsistent_output++))
        fi
    done
    
    if [ $inconsistent_output -eq 0 ]; then
        log_output "${GREEN}‚úÖ Output formatting is consistent${NC}"
    else
        log_output "${YELLOW}   Fix: Add consistent color coding and status indicators${NC}"
    fi
}
check_output_formatting
log_output ""

# Check 9: Code duplication
log_output "${BLUE}### 9. Checking for code duplication...${NC}"
check_code_duplication() {
    local duplicated_code=0
    
    # Look for common patterns that should be in library functions
    local common_patterns=(
        "cd.*dirname.*BASH_SOURCE"
        "find.*-name.*sh.*-type f"
        "safe_grep_count.*2>/dev/null.*echo.*0"
        "mkdir -p.*structure.*old"
    )
    
    for pattern in "${common_patterns[@]}"; do
        local usage_count=$(find_shell_scripts "$CONSTRUCT_DEV/CONSTRUCT/scripts" | xargs grep -l "$pattern" 2>/dev/null | wc -l | tr -d ' ')
        
        if [ "$usage_count" -gt 2 ]; then
            log_output "${YELLOW}‚ö†Ô∏è Pattern used in $usage_count scripts: $pattern${NC}"
            log_output "${YELLOW}   Consider moving to library function${NC}"
            ((duplicated_code++))
        fi
    done
    
    if [ $duplicated_code -eq 0 ]; then
        log_output "${GREEN}‚úÖ No significant code duplication detected${NC}"
    else
        log_output "${YELLOW}   Fix: Extract common patterns into library functions${NC}"
    fi
}
check_code_duplication
log_output ""

# Check 10: Hybrid symlink naming validation
log_output "${BLUE}### 10. Checking hybrid symlink naming...${NC}"
check_symlink_naming() {
    local violations=0
    
    # Check: All *-sym.* files must be actual symlinks
    while IFS= read -r -d '' file; do
        if [ ! -L "$file" ]; then
            log_output "${RED}‚ùå ORPHAN: $file claims to be symlink but isn't!${NC}"
            ((violations++))
        fi
    done < <(find "$CONSTRUCT_DEV" -name "*-sym.*" -print0 2>/dev/null)
    
    # Check: Symlinks should use -sym naming for clarity
    local unnamed_symlinks=0
    while IFS= read -r -d '' file; do
        local basename_file=$(basename "$file")
        if [[ ! "$basename_file" =~ -sym\. ]] && [[ ! "$basename_file" == "CONSTRUCT" ]]; then
            log_output "${YELLOW}‚ö†Ô∏è Symlink without -sym naming: $file${NC}"
            ((unnamed_symlinks++))
        fi
    done < <(find "$CONSTRUCT_DEV" -type l -print0 2>/dev/null)
    
    if [ $violations -eq 0 ]; then
        log_output "${GREEN}‚úÖ All -sym files are actual symlinks${NC}"
    else
        log_output "${YELLOW}   Fix: Remove orphan files or recreate as symlinks${NC}"
        VIOLATIONS=$((VIOLATIONS + violations))
    fi
    
    if [ $unnamed_symlinks -eq 0 ]; then
        log_output "${GREEN}‚úÖ All symlinks follow naming convention${NC}"
    else
        log_output "${YELLOW}   Consider: Rename symlinks to use -sym pattern for clarity${NC}"
    fi
}
check_symlink_naming
log_output ""

# Check 11: Test coverage
log_output "${BLUE}### 11. Checking test coverage...${NC}"
check_test_coverage() {
    local missing_tests=0
    
    # Count scripts vs tests
    local script_count=$(find_shell_scripts "$CONSTRUCT_DEV/CONSTRUCT/scripts" | wc -l | tr -d ' ')
    local test_count=$(find_shell_scripts "$CONSTRUCT_DEV/tests" 2>/dev/null | grep -c "test" | tr -d ' \n' || echo "0")
    
    log_output "Scripts: $script_count, Tests: $test_count"
    
    if [ "$test_count" -eq 0 ]; then
        log_output "${YELLOW}‚ö†Ô∏è No test files found in tests/ directory${NC}"
        missing_tests=1
    elif [ "$test_count" -lt $((script_count / 2)) ]; then
        log_output "${YELLOW}‚ö†Ô∏è Low test coverage: $test_count tests for $script_count scripts${NC}"
        missing_tests=1
    fi
    
    if [ $missing_tests -eq 0 ]; then
        log_output "${GREEN}‚úÖ Test coverage appears adequate${NC}"
    else
        log_output "${YELLOW}   Fix: Add test files for critical scripts${NC}"
    fi
}
check_test_coverage
log_output ""

# Generate summary
log_output ""
log_output "${BLUE}üìã CONSTRUCT Quality Check Summary${NC}"
log_output "============================================="

if [ $VIOLATIONS -eq 0 ]; then
    log_output "${GREEN}‚úÖ QUALITY CHECK PASSED${NC}"
    log_output "${GREEN}   All CONSTRUCT development standards met${NC}"
    log_output "${GREEN}   Code is production-ready${NC}"
else
    log_output "${YELLOW}‚ö†Ô∏è QUALITY IMPROVEMENTS NEEDED${NC}"
    log_output "${YELLOW}   Found $VIOLATIONS quality issues${NC}"
    log_output "${YELLOW}   Consider addressing issues before major commits${NC}"
fi

log_output ""
log_output "Quality standards checked:"
log_output "  - Shell script syntax validation"
log_output "  - Error handling patterns"
log_output "  - Hardcoded path detection"
log_output "  - Function documentation"
log_output "  - Script permissions"
log_output "  - Configuration file validation"
log_output "  - Library function usage"
log_output "  - Output formatting consistency"
log_output "  - Code duplication detection"
log_output "  - Hybrid symlink naming validation"
log_output "  - Test coverage analysis"
log_output ""
log_output "Next steps:"
log_output "  ./CONSTRUCT/scripts/scan_construct_structure.sh  # Update structure analysis"
log_output "  ./CONSTRUCT/scripts/update-context.sh           # Update development context"

# Add report completion
echo ""
echo -e "${GREEN}üìÑ Quality report saved to: $REPORT_FILE${NC}"

# Exit with violation count (0 = success)
exit $VIOLATIONS