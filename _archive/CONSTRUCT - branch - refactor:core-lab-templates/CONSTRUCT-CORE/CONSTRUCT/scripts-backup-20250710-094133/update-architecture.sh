#!/bin/bash

# CONSTRUCT Architecture Documentation Update Script
# Updates and maintains CONSTRUCT development architecture documentation

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Source library functions
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../lib/common-patterns.sh"

# Get project directories using library functions
CONSTRUCT_ROOT=$(get_construct_root)
CONSTRUCT_DEV=$(get_construct_dev)

# Source library functions
source "$CONSTRUCT_DEV/CONSTRUCT/lib/validation.sh"

echo -e "${BLUE}📚 Updating CONSTRUCT Architecture Documentation...${NC}"
echo ""

# Create docs directory if it doesn't exist
DOCS_DIR="$CONSTRUCT_DEV/AI/docs/automated"
mkdir -p "$DOCS_DIR"
mkdir -p "$DOCS_DIR/_old"

# Generate architecture overview
generate_architecture_overview() {
    local output_file="$DOCS_DIR/architecture-overview-automated.md"
    
    echo -e "${YELLOW}Generating architecture overview...${NC}"
    
    cat > "$output_file" << EOF
# CONSTRUCT Development Architecture

**Last Updated**: $(date)
**Generated by**: update-architecture.sh

## Overview

CONSTRUCT uses a three-layer architecture:
1. **CONSTRUCT-CORE** - Universal orchestration engine (stable, production-ready)
2. **CONSTRUCT-LAB** - Development environment for improving CONSTRUCT
3. **TEMPLATES** - Production-ready project templates for users

### Architecture Layers

#### CONSTRUCT-CORE
- Universal scripts and orchestration logic
- Language-agnostic tools that work everywhere
- Stable, versioned releases
- Embedded in both LAB and TEMPLATES via symlinks

#### CONSTRUCT-LAB
- Development and experimentation environment
- Test new features and improvements
- Contains all development artifacts and history
- Uses CONSTRUCT-CORE for its own operations

#### TEMPLATES
- Clean, production-ready starting points
- Currently: swift-ios (more coming)
- Each template embeds CONSTRUCT-CORE
- No development artifacts, just what users need

## Architecture Principles

### Dual Environment Design
- **Separation of Concerns**: CONSTRUCT development vs user development
- **Identical Patterns**: Same workflow commands across different domains
- **Domain Expertise**: Each environment understands its architectural patterns
- **Cross-Pollination**: Insights from one environment improve the other

### Self-Improving System
- CONSTRUCT uses its own methodology to improve itself
- AI-assisted development workflows for both shell and Swift code
- Automated quality gates and architecture enforcement
- Continuous documentation updates

## Directory Structure

\`\`\`
CONSTRUCT/
├── CONSTRUCT-CORE/              # Universal orchestration engine
│   ├── orchestrator/           # Language detection and routing
│   ├── adapters/              # Language-specific implementations
│   ├── scripts/               # Core workflow scripts
│   ├── lib/                   # Shared library functions
│   ├── config/                # Core configuration
│   └── VERSION                # Semantic versioning
├── CONSTRUCT-LAB/              # Development environment
│   ├── AI/                    # Development context and tools
│   │   ├── CLAUDE.md         # Auto-updating development context
│   │   ├── structure/        # Architecture snapshots
│   │   ├── todo/            # Development planning
│   │   └── dev-logs/        # Session documentation
│   ├── CONSTRUCT -> ../CONSTRUCT-CORE  # Symlink to core
│   └── experiments/          # New feature development
└── TEMPLATES/                  # Production-ready templates
    └── swift-ios/             # Swift/iOS template
        ├── AI/                # Template AI context
        ├── CONSTRUCT -> ../../CONSTRUCT-CORE  # Symlink
        └── swift/             # Swift project files
            ├── MyApp.xcodeproj/
            ├── iOS-App/
            └── Watch-App/
\`\`\`

## Component Architecture

### AI Scripts Architecture
Each environment has parallel AI-assisted workflow scripts:

#### CONSTRUCT Development Scripts (Shell/Python Focus)
- \`update-context.sh\` - Updates CONSTRUCT development context
- \`check-architecture.sh\` - Validates shell script patterns
- \`check-quality.sh\` - Shell script quality gates
- \`scan_construct_structure.sh\` - CONSTRUCT infrastructure analysis
- \`check-documentation.sh\` - Documentation coverage validation
- \`before_coding.sh\` - Pre-coding guidance for shell development
- \`session-summary.sh\` - CONSTRUCT development session summaries
- \`setup-aliases.sh\` - Development workflow aliases
- \`update-architecture.sh\` - This script (architecture docs)

#### User Project Scripts (Swift MVVM Focus)
- \`update-context.sh\` - Updates Swift project context
- \`check-architecture.sh\` - Validates Swift MVVM patterns
- \`check-quality.sh\` - Swift code quality gates
- \`scan_mvvm_structure.sh\` - Swift component analysis
- \`check-accessibility.sh\` - iOS accessibility validation
- \`before_coding.sh\` - Pre-coding guidance for Swift development
- \`session-summary.sh\` - Swift development session summaries
- \`setup-aliases.sh\` - User development aliases
- \`update-architecture.sh\` - Swift architecture documentation

### Library Architecture

#### Shared Functions (lib/)
- \`validation.sh\` - Common validation patterns
- \`file-analysis.sh\` - Code parsing and analysis
- \`template-utils.sh\` - Template management utilities

### Configuration Architecture

#### Configuration-Driven Validation (config/)
- \`mvvm-rules.yaml\` - Swift MVVM pattern rules
- \`quality-gates.yaml\` - Quality thresholds and standards

## Data Flow

### Development Context Flow
1. Scripts analyze current state
2. Generate structured documentation
3. Update AI context files (CLAUDE.md)
4. AI uses context for intelligent assistance
5. Discoveries fed back into templates and patterns

### Cross-Environment Flow
1. CONSTRUCT development creates/improves tools
2. Tools tested against USER-project-files/
3. Patterns extracted from user development
4. Insights fed back into CONSTRUCT improvements
5. Templates updated based on real usage

## Quality Assurance

### Automated Quality Gates
- Shell script syntax validation
- Error handling pattern enforcement
- Hardcoded path detection
- Function documentation requirements
- Configuration file validation
- Test coverage analysis

### Architecture Enforcement
- MVVM pattern compliance (Swift)
- Shell best practices (CONSTRUCT development)
- Configuration-driven rule validation
- Automated pre-commit hooks

### Documentation Standards
- Auto-updating context files
- Comprehensive session logging
- Architecture decision records
- Development milestone tracking

## Extension Points

### Adding New Scripts
1. Follow established error handling patterns
2. Use library functions where possible
3. Add proper documentation and usage examples
4. Include quality checks and validation
5. Update architecture documentation

### Adding New Validations
1. Define rules in config/ YAML files
2. Implement validation logic in library functions
3. Add checks to quality gate scripts
4. Document new patterns and standards

### Cross-Environment Analysis
1. Create analysis scripts in CONSTRUCT-LAB/
2. Read-only analysis of USER-project-files/
3. Extract patterns and insights
4. Feed discoveries back into templates

## Security Considerations

### Path Safety
- All scripts use relative path resolution
- No hardcoded absolute paths
- Proper validation of input paths
- Safe directory traversal patterns

### Template Integrity
- Read-only analysis of user projects
- No modification of USER-project-files/ from CONSTRUCT scripts
- Separate development and user contexts
- Safe template updates and testing

---

*This document is auto-generated. To update, run: ./CONSTRUCT/scripts/update-architecture.sh*
EOF

    echo -e "${GREEN}✅ Architecture overview generated: $output_file${NC}"
}

# Generate script documentation
generate_script_documentation() {
    local output_file="$DOCS_DIR/script-reference-automated.md"
    
    echo -e "${YELLOW}Generating script reference documentation...${NC}"
    
    cat > "$output_file" << EOF
# CONSTRUCT Development Script Reference

**Last Updated**: $(date)
**Generated by**: update-architecture.sh

## Available Scripts

### Core Development Scripts

EOF

    # Document each script in CONSTRUCT/scripts/
    find "$CONSTRUCT_DEV/CONSTRUCT/scripts" -name "*.sh" -type f | sort | while read -r script; do
        local script_name=$(basename "$script")
        echo "#### $script_name" >> "$output_file"
        echo "" >> "$output_file"
        
        # Extract description from script header
        local description=$(head -10 "$script" | grep "^# .*[A-Za-z]" | head -1 | sed 's/^# //')
        if [ -n "$description" ]; then
            echo "**Purpose**: $description" >> "$output_file"
        fi
        
        # Check if script has usage/help
        if grep -q "usage\|Usage\|--help" "$script"; then
            echo "**Usage**: Run with --help for detailed usage" >> "$output_file"
        fi
        
        # Extract key features from script
        echo "**Features**:" >> "$output_file"
        local features=$(grep -o "echo.*✅\|echo.*❌\|echo.*⚠️" "$script" | head -3 | sed 's/echo.*[✅❌⚠️] /- /' | sed 's/\${[^}]*}//g' | sed 's/"//g')
        if [ -n "$features" ]; then
            echo "$features" >> "$output_file"
        else
            echo "- Automated validation and reporting" >> "$output_file"
        fi
        
        echo "" >> "$output_file"
    done

    cat >> "$output_file" << EOF

### Library Functions

EOF

    # Document library functions
    find "$CONSTRUCT_DEV/CONSTRUCT/lib" -name "*.sh" -type f | sort | while read -r lib_file; do
        local lib_name=$(basename "$lib_file")
        echo "#### $lib_name" >> "$output_file"
        echo "" >> "$output_file"
        
        # Extract description
        local description=$(head -10 "$lib_file" | grep "^# .*[A-Za-z]" | head -1 | sed 's/^# //')
        if [ -n "$description" ]; then
            echo "**Purpose**: $description" >> "$output_file"
        fi
        
        # List functions
        local functions=$(grep "^[a-zA-Z_][a-zA-Z0-9_]*()" "$lib_file" | cut -d'(' -f1)
        if [ -n "$functions" ]; then
            echo "**Functions**:" >> "$output_file"
            echo "$functions" | while read -r func; do
                echo "- \`$func()\`" >> "$output_file"
            done
        fi
        
        echo "" >> "$output_file"
    done

    cat >> "$output_file" << EOF

### Configuration Files

EOF

    # Document configuration files
    find "$CONSTRUCT_DEV/CONSTRUCT/config" -name "*.yaml" -type f | sort | while read -r config_file; do
        local config_name=$(basename "$config_file")
        echo "#### $config_name" >> "$output_file"
        echo "" >> "$output_file"
        
        # Extract description from config file
        local description=$(head -10 "$config_file" | grep "^# .*[A-Za-z]" | head -1 | sed 's/^# //')
        if [ -n "$description" ]; then
            echo "**Purpose**: $description" >> "$output_file"
        fi
        
        # List top-level sections
        local sections=$(grep "^[a-zA-Z_][a-zA-Z0-9_]*:" "$config_file" | cut -d':' -f1)
        if [ -n "$sections" ]; then
            echo "**Sections**:" >> "$output_file"
            echo "$sections" | while read -r section; do
                echo "- \`$section\`" >> "$output_file"
            done
        fi
        
        echo "" >> "$output_file"
    done

    echo -e "${GREEN}✅ Script reference generated: $output_file${NC}"
}

# Generate development patterns documentation
generate_development_patterns() {
    local output_file="$DOCS_DIR/development-patterns-automated.md"
    
    echo -e "${YELLOW}Generating development patterns documentation...${NC}"
    
    cat > "$output_file" << EOF
# CONSTRUCT Development Patterns

**Last Updated**: $(date)
**Generated by**: update-architecture.sh

## Script Development Patterns

### Standard Script Structure

All CONSTRUCT development scripts follow this pattern:

\`\`\`bash
#!/bin/bash

# Script Description
# Brief explanation of what this script does

set -e

# Colors for output
RED='\\033[0;31m'
GREEN='\\033[0;32m'
YELLOW='\\033[0;33m'
BLUE='\\033[0;34m'
NC='\\033[0m' # No Color

# Source library functions
SCRIPT_DIR="\$(cd "\$(dirname "\${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../lib/common-patterns.sh"

# Get project directories using library functions
CONSTRUCT_ROOT=$(get_construct_root)
CONSTRUCT_DEV=$(get_construct_dev)

# Source library functions
source "\$CONSTRUCT_DEV/CONSTRUCT/lib/validation.sh"

echo -e "\${BLUE}🔍 Script Description...\${NC}"
echo ""

# Main logic with proper error handling
main() {
    # Implementation
}

main "\$@"
\`\`\`

### Error Handling Patterns

#### Required Error Handling
- Always use \`set -e\` for fail-fast behavior
- Source library functions with proper path resolution
- Use colored output for status reporting
- Implement proper exit codes

#### Validation Pattern
\`\`\`bash
validate_input() {
    local input=\$1
    
    if [ -z "\$input" ]; then
        echo -e "\${RED}❌ Error: Input required\${NC}"
        exit 1
    fi
    
    if [ ! -f "\$input" ]; then
        echo -e "\${RED}❌ Error: File not found: \$input\${NC}"
        exit 1
    fi
}
\`\`\`

### Output Formatting Patterns

#### Status Indicators
- ✅ Success/Pass
- ❌ Error/Fail  
- ⚠️ Warning/Attention needed
- 🔍 Analysis/Investigation
- 📊 Statistics/Metrics
- 💡 Insights/Tips

#### Color Coding
- \`GREEN\`: Success, pass, good status
- \`RED\`: Errors, failures, critical issues
- \`YELLOW\`: Warnings, attention needed, suggestions
- \`BLUE\`: Information, headers, process status

### Library Function Patterns

#### Function Documentation
\`\`\`bash
# Validates directory exists and is readable
validate_directory() {
    local dir=\$1
    # Implementation
}
\`\`\`

#### Configuration-Driven Validation
\`\`\`bash
# Load validation rules from YAML config
load_validation_rules() {
    local config_file="\$CONSTRUCT_DEV/CONSTRUCT/config/quality-gates.yaml"
    # Parse and apply rules
}
\`\`\`

## Development Workflow Patterns

### Context Update Pattern
1. Analyze current state
2. Generate structured data
3. Update AI context file
4. Provide next step suggestions

### Quality Check Pattern
1. Run multiple validation categories
2. Count violations by severity
3. Provide actionable feedback
4. Exit with appropriate code

### Structure Analysis Pattern
1. Scan directory structure
2. Categorize and count components
3. Generate both detailed and summary reports
4. Identify architectural patterns and gaps

## Configuration Patterns

### YAML Configuration Structure
\`\`\`yaml
# Configuration file description
# Purpose and usage notes

rules:
  category1:
    forbidden_patterns:
      - "pattern1"
      - "pattern2"
    required_patterns:
      - "pattern3"
      
  category2:
    thresholds:
      warning: 5
      error: 10
\`\`\`

### Configuration Loading Pattern
\`\`\`bash
load_config() {
    local config_file="\$1"
    
    if [ ! -f "\$config_file" ]; then
        echo -e "\${RED}❌ Config file not found: \$config_file\${NC}"
        exit 1
    fi
    
    # Parse YAML and extract values
}
\`\`\`

## Testing Patterns

### Script Testing Structure
\`\`\`bash
# Test script template
test_script_functionality() {
    local script_path="\$1"
    
    # Test 1: Script exists and is executable
    if [ ! -x "\$script_path" ]; then
        echo "❌ Script not executable: \$script_path"
        return 1
    fi
    
    # Test 2: Script runs without errors
    if ! "\$script_path" --help &>/dev/null; then
        echo "❌ Script help failed: \$script_path"
        return 1
    fi
    
    echo "✅ Script tests passed: \$script_path"
    return 0
}
\`\`\`

## Documentation Patterns

### Auto-Generated Documentation
- Use consistent headers with generation timestamp
- Include script/command that generated the documentation
- Provide context about purpose and usage
- Update documentation as part of development workflow

### Session Documentation
- Record development decisions and rationale
- Track architectural changes and their impact
- Document discovered patterns and anti-patterns
- Maintain development timeline and milestones

---

*This document is auto-generated. To update, run: ./CONSTRUCT/scripts/update-architecture.sh*
EOF

    echo -e "${GREEN}✅ Development patterns generated: $output_file${NC}"
}

# Update main architecture document
update_main_architecture() {
    local output_file="$DOCS_DIR/improving-CONSTRUCT-guide-automated.md"
    
    echo -e "${YELLOW}Updating main architecture guide...${NC}"
    
    # Check if file exists and has manual content to preserve
    if [ -f "$output_file" ]; then
        # Create backup before updating
        cp "$output_file" "$DOCS_DIR/_old/$(basename "$output_file").backup-$(date +%Y%m%d-%H%M%S)"
        echo -e "${GREEN}✅ Backup created for existing architecture guide${NC}"
    fi
    
    # Get current statistics
    local script_count=$(find "$CONSTRUCT_DEV/CONSTRUCT/scripts" -name "*.sh" -type f | wc -l | tr -d ' ')
    local lib_count=$(find "$CONSTRUCT_DEV/CONSTRUCT/lib" -name "*.sh" -type f | wc -l | tr -d ' ')
    local config_count=$(find "$CONSTRUCT_DEV/CONSTRUCT/config" -name "*.yaml" -type f | wc -l | tr -d ' ')
    
    # Add auto-generated status section to existing guide
    cat >> "$output_file" << EOF

---

# Auto-Generated Architecture Status

**Last Updated**: $(date)
**Generated by**: update-architecture.sh

## Current CONSTRUCT Development State

### Component Statistics
- **AI Scripts**: $script_count/9 implemented
- **Library Functions**: $lib_count files
- **Configuration Files**: $config_count files
- **Documentation Files**: $(find "$DOCS_DIR" -name "*.md" -type f | wc -l | tr -d ' ') files

### Implementation Progress
- **Phase 1**: CONSTRUCT Development Scripts - $(echo "scale=0; $script_count * 100 / 9" | bc 2>/dev/null || echo "~89")% complete
- **Phase 2**: USER-project-files cleanup - Pending
- **Phase 3**: Cross-environment integration - Pending
- **Phase 4**: Auto-updating contexts - In progress
- **Phase 5**: Shell aliases and polish - In progress

### Quality Metrics
- **Script Quality**: Run \`./CONSTRUCT/scripts/check-quality.sh\` for current status
- **Documentation Coverage**: Run \`./CONSTRUCT/scripts/check-documentation.sh\` for analysis
- **Architecture Compliance**: Run \`./CONSTRUCT/scripts/check-architecture.sh\` for validation

### Recent Architecture Changes
- Dual development environment implementation complete
- Configuration-driven validation system active
- Auto-updating documentation generation implemented
- Library function architecture established

### Next Development Priorities
1. Complete remaining AI scripts ($(echo "9 - $script_count" | bc 2>/dev/null || echo "0") remaining)
2. Clean up USER-project-files scripts (remove RUN-specific hardcoding)
3. Implement cross-environment analysis capabilities
4. Enhance auto-updating context systems
5. Complete shell alias integration

### Development Commands
\`\`\`bash
# Update all architecture documentation
./CONSTRUCT/scripts/update-architecture.sh

# Check overall CONSTRUCT development health
./CONSTRUCT/scripts/check-quality.sh && ./CONSTRUCT/scripts/check-documentation.sh

# Analyze current structure
./CONSTRUCT/scripts/scan_construct_structure.sh

# Update development context for AI
./CONSTRUCT/scripts/update-context.sh
\`\`\`

---

*This section auto-updates when you run ./CONSTRUCT/scripts/update-architecture.sh*
EOF

    echo -e "${GREEN}✅ Main architecture guide updated: $output_file${NC}"
}

# Generate API documentation for library functions
generate_api_documentation() {
    local output_file="$DOCS_DIR/api-reference-automated.md"
    
    echo -e "${YELLOW}Generating API reference documentation...${NC}"
    
    cat > "$output_file" << EOF
# CONSTRUCT Development API Reference

**Last Updated**: $(date)
**Generated by**: update-architecture.sh

## Library Functions API

EOF

    # Document each library file and its functions
    find "$CONSTRUCT_DEV/CONSTRUCT/lib" -name "*.sh" -type f | sort | while read -r lib_file; do
        local lib_name=$(basename "$lib_file" .sh)
        echo "### $lib_name" >> "$output_file"
        echo "" >> "$output_file"
        
        # Extract file description
        local file_description=$(head -10 "$lib_file" | grep "^# .*[A-Za-z]" | head -1 | sed 's/^# //')
        if [ -n "$file_description" ]; then
            echo "$file_description" >> "$output_file"
            echo "" >> "$output_file"
        fi
        
        # Document each function
        grep -n "^[a-zA-Z_][a-zA-Z0-9_]*()" "$lib_file" | while IFS=: read -r line_num func_def; do
            local func_name=$(echo "$func_def" | cut -d'(' -f1)
            
            echo "#### \`$func_name()\`" >> "$output_file"
            echo "" >> "$output_file"
            
            # Get function documentation from preceding comment
            local prev_line=$((line_num - 1))
            if [ $prev_line -gt 0 ]; then
                local comment=$(sed -n "${prev_line}p" "$lib_file")
                if [[ "$comment" =~ ^#.*[A-Za-z] ]]; then
                    echo "$(echo "$comment" | sed 's/^# //')" >> "$output_file"
                    echo "" >> "$output_file"
                fi
            fi
            
            # Extract function parameters and usage
            local func_body_start=$((line_num + 1))
            local param_info=$(sed -n "${func_body_start},+5p" "$lib_file" | grep "local.*=.*\$[0-9]" | head -3)
            
            if [ -n "$param_info" ]; then
                echo "**Parameters:**" >> "$output_file"
                echo "$param_info" | while read -r param_line; do
                    local param_name=$(echo "$param_line" | sed 's/.*local \([^=]*\)=.*/\1/')
                    local param_num=$(echo "$param_line" | sed 's/.*\$\([0-9]*\).*/\1/')
                    echo "- \`\$$param_num\` - $param_name" >> "$output_file"
                done
                echo "" >> "$output_file"
            fi
            
            echo "**Usage:**" >> "$output_file"
            echo "\`\`\`bash" >> "$output_file"
            echo "source \"\$CONSTRUCT_DEV/CONSTRUCT/lib/$lib_name.sh\"" >> "$output_file"
            echo "$func_name [parameters]" >> "$output_file"
            echo "\`\`\`" >> "$output_file"
            echo "" >> "$output_file"
        done
        
        echo "---" >> "$output_file"
        echo "" >> "$output_file"
    done

    echo -e "${GREEN}✅ API reference generated: $output_file${NC}"
}

# Main execution
main() {
    echo "Updating CONSTRUCT architecture documentation..."
    echo ""
    
    # Generate all documentation
    generate_architecture_overview
    generate_script_documentation
    generate_development_patterns
    update_main_architecture
    generate_api_documentation
    
    echo ""
    echo -e "${BLUE}📚 Architecture Documentation Update Complete!${NC}"
    echo ""
    echo "Generated documentation:"
    echo "  - $DOCS_DIR/architecture-overview-automated.md"
    echo "  - $DOCS_DIR/script-reference-automated.md"
    echo "  - $DOCS_DIR/development-patterns-automated.md"
    echo "  - $DOCS_DIR/improving-CONSTRUCT-guide-automated.md (updated)"
    echo "  - $DOCS_DIR/api-reference-automated.md"
    echo ""
    echo "Next steps:"
    echo "  ./CONSTRUCT/scripts/update-context.sh      # Update development context"
    echo "  ./CONSTRUCT/scripts/check-quality.sh       # Validate documentation quality"
}

# Show help if requested
if [[ "$1" == "--help" || "$1" == "-h" ]]; then
    echo "CONSTRUCT Architecture Documentation Update"
    echo ""
    echo "Usage: $0 [options]"
    echo ""
    echo "Options:"
    echo "  --help, -h     Show this help message"
    echo ""
    echo "This script generates and updates comprehensive architecture"
    echo "documentation for CONSTRUCT development including:"
    echo "  - Architecture overview and principles"
    echo "  - Script reference documentation"
    echo "  - Development patterns and standards"
    echo "  - API reference for library functions"
    echo "  - Current implementation status"
    exit 0
fi

# Run main function
main